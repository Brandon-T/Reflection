{$i reflection/reflection.simba}

type
  Polygon = record
    XPoints: Array of Int32;
    YPoints: Array of Int32;
    NPoints: Int32;
  end;

Procedure DrawPolygons(XPoints, YPoints: Array of Int32; nPoints: Int32; bmp: TMufasaBitmap; Colour: TColor);
var
  i: Integer;
  size: Int32;
begin
  size := NPoints - 2;
  if size = -1 then
    exit;

  for i := 0 to size do
  begin
    bmp.LineTo(Point(XPoints[i], YPoints[i]), Point(XPoints[i + 1], YPoints[i + 1]), Colour);
  end;

  bmp.LineTo(Point(XPoints[size + 1], YPoints[size + 1]), Point(XPoints[0], YPoints[0]), Colour);
end;

Function GetTileHeight(x, y, plane: Int32): Int32;
var
  xSize, ySize: Int32;
  var1, var2, var3, var4: Int32;
begin
  xSize := Sar(x, 7);
  ySize := Sar(y, 7);

  if (xSize >= 0) and (ySize >= 0) and (xSize < 104) and (ySize < 104) then
  begin
    if (plane < 3) and ((CACHED_TILE_SETTINGS[1][xSize][ySize] and 2) = 2) then
    begin
      Inc(plane);
    end;

    var1 := x and 127;
    var2 := y and 127;
    var3 := Sar(((var1 * CACHED_TILE_HEIGHTS[plane][xSize + 1][ySize]) + ((128 - var1) * CACHED_TILE_HEIGHTS[plane][xSize][ySize])), 7);
    var4 := Sar(((CACHED_TILE_HEIGHTS[plane][xSize][ySize + 1] * (128 - var1)) + (var1 * CACHED_TILE_HEIGHTS[plane][xSize + 1][ySize + 1])), 7);

    Result := Sar(((128 - var2) * var3 + var2 * var4), 7);
    Exit;
  end;

  Exit(0);
end;

Function ProjectPoint(point: TVector; localX, localY, localZ, orientation, cameraX, cameraY, cameraZ, sinYaw, cosYaw, sinPitch, cosPitch, viewPortWidth, viewPortHeight, viewPortScale: Int32): TPoint;
var
  p: TVector;
  x, y, z, calculation: Int32;
begin
  p := [point.x, point.z, point.y];

  // Rotate based on orientation
  p := [Sar(((p.x * COSINE[orientation]) + (p.y * SINE[orientation])), 16),
        Sar(((p.y * COSINE[orientation]) - (p.x * SINE[orientation])), 16),
        p.z];

  // Translate to local coords
  p.x += localX;
  p.y += localY;
  p.z += localZ;

  // Translate to camera
  p.x -= cameraX;
  p.y -= cameraY;
  p.z -= cameraZ;

  // Project to canvas
  x := p.x;
  y := p.y;
  z := p.z;

  calculation := Sar(((x * cosYaw) + (y * sinYaw)), 16);
  y := Sar(((y * cosYaw) - (x * sinYaw)), 16);
  x := calculation;
  calculation := Sar(((z * cosPitch) - (y * sinPitch)), 16);
  z := Sar(((y * cosPitch) + (z * sinPitch)), 16);
  y := calculation;

  if (z >= 50) then
  begin
    Result.X := (x * viewPortScale div z) + (viewPortWidth div 2);
    Result.Y := (y * viewPortScale div z) + (viewPortHeight div 2);
    Exit;
  end

  Result.X := -1;
  Result.Y := -1;
end;

Function ProjectTriangles(model: RSModel; localX, localY, localZ, orientation: Int32): Array of Polygon;
var
  i: Int32;
  cameraX, cameraY, cameraZ, cameraYaw, cameraPitch: Int32;
  viewPortScale, viewPortHeight, viewPortWidth: Int32;
  sinPitch, cosPitch, sinYaw, cosYaw: Int32;
  triangles: Array of TTriangle;
  A, B, C: TPoint;
  Face: Polygon;

  Function isValidPoint(point: TPoint): Boolean;
  begin
    Result := (point.x <> -1) and (point.y <> -1);
  end;
begin
  cameraX := RSCamera.X;
  cameraY := RSCamera.Y;
  cameraZ := RSCamera.Z;
  cameraYaw := RSCamera.Yaw;
  cameraPitch := RSCamera.Pitch;

  viewPortScale := RSClient.ViewPortScale;
  viewPortWidth := RSClient.ViewPortWidth;
  viewPortHeight := RSClient.ViewPortHeight;

  sinPitch := SINE[cameraPitch];
  cosPitch := COSINE[cameraPitch];
  sinYaw := SINE[cameraYaw];
  cosYaw := COSINE[cameraYaw];

  triangles := model.TriangleFaces;

  for i := 0 to high(triangles) do
  begin
    A := ProjectPoint(triangles[i].a, localX, localY, localZ,
                      orientation, cameraX, cameraY, cameraZ,
                      sinYaw, cosYaw, sinPitch, cosPitch,
                      viewPortWidth, viewPortHeight, viewPortScale);

    B := ProjectPoint(triangles[i].b, localX, localY, localZ,
                      orientation, cameraX, cameraY, cameraZ,
                      sinYaw, cosYaw, sinPitch, cosPitch,
                      viewPortWidth, viewPortHeight, viewPortScale);

    C := ProjectPoint(triangles[i].c, localX, localY, localZ,
                      orientation, cameraX, cameraY, cameraZ,
                      sinYaw, cosYaw, sinPitch, cosPitch,
                      viewPortWidth, viewPortHeight, viewPortScale);

    if isValidPoint(A) and isValidPoint(b) and isValidPoint(c) then
    begin
      Face := [[A.X, B.X, C.X], [A.Y, B.Y, C.Y], 3];
      Result += Face;
    end;
  end;
end;

Function ProjectTriangles(model: RSAnimatedModel; localX, localY, localZ, orientation: Int32): Array of Polygon; overload;
var
  i: Int32;
  cameraX, cameraY, cameraZ, cameraYaw, cameraPitch: Int32;
  viewPortScale, viewPortHeight, viewPortWidth: Int32;
  sinPitch, cosPitch, sinYaw, cosYaw: Int32;
  triangles: Array of TTriangle;
  A, B, C: TPoint;
  Face: Polygon;

  Function isValidPoint(point: TPoint): Boolean;
  begin
    Result := (point.x <> -1) and (point.y <> -1);
  end;
begin
  cameraX := RSCamera.X;
  cameraY := RSCamera.Y;
  cameraZ := RSCamera.Z;
  cameraYaw := RSCamera.Yaw;
  cameraPitch := RSCamera.Pitch;

  viewPortScale := RSClient.ViewPortScale;
  viewPortWidth := RSClient.ViewPortWidth;
  viewPortHeight := RSClient.ViewPortHeight;

  sinPitch := SINE[cameraPitch];
  cosPitch := COSINE[cameraPitch];
  sinYaw := SINE[cameraYaw];
  cosYaw := COSINE[cameraYaw];

  triangles := model.triangles;

  for i := 0 to high(triangles) do
  begin
    A := ProjectPoint(triangles[i].a, localX, localY, localZ,
                      orientation, cameraX, cameraY, cameraZ,
                      sinYaw, cosYaw, sinPitch, cosPitch,
                      viewPortWidth, viewPortHeight, viewPortScale);

    B := ProjectPoint(triangles[i].b, localX, localY, localZ,
                      orientation, cameraX, cameraY, cameraZ,
                      sinYaw, cosYaw, sinPitch, cosPitch,
                      viewPortWidth, viewPortHeight, viewPortScale);

    C := ProjectPoint(triangles[i].c, localX, localY, localZ,
                      orientation, cameraX, cameraY, cameraZ,
                      sinYaw, cosYaw, sinPitch, cosPitch,
                      viewPortWidth, viewPortHeight, viewPortScale);

    if isValidPoint(A) and isValidPoint(b) and isValidPoint(c) then
    begin
      Face := [[A.X, B.X, C.X], [A.Y, B.Y, C.Y], 3];
      Result += Face;
    end;
  end;
end;

Procedure DrawPlayer(player: RSPlayer; Bmp: TMufasaBitmap; Colour: TColor);
var
  i: Int32;
  orientation: Int32;
  localX, localY, localZ: Int32;
  model: RSAnimatedModel;
  triangles: Array of Polygon;
begin
  orientation := player.Orientation;

  localX := player.LocalX;
  localY := player.LocalY;
  localZ := GetTileHeight(localX, localY, RSClient.plane);

  model := Player.AnimatedModel;
  triangles := ProjectTriangles(model, localX, localY, localZ, orientation);
  model.Free;

  for i := 0 to high(triangles) do
  begin
    DrawPolygons(Triangles[I].XPoints, Triangles[I].YPoints, Triangles[I].NPoints, Bmp, Colour);
  end;
end;

var
  i, j, w, h: Int32;
  players: array of RSPlayer;
  debugBuffer: ^UInt8;
  bmp: TMufasaBitmap;
begin
  RSetup(736);

  GetClientDimensions(w, h);
  DebugBuffer := EIOS_GetDebugImageBuffer(R_EIOS);

  Bmp.Init;
  Bmp.SetPersistentMemory(PtrUInt(debugBuffer), w, h);
  Bmp.Rectangle([0, 0, w - 1, h - 1], $00);

  players := [RSPlayer.Me];

  for i := 0 to high(players) do
  begin
    if (players[i].ref <> nil) then
    begin
      for j := 0 to 1000 do
      begin
        DrawPlayer(players[i], bmp, $FFFFFF);

        //if j mod 2 = 0 then
          Bmp.Rectangle([0, 0, w - 1, h - 1], $00);
      end;
    end;
  end;

  RSTypeArray(players).Free;

  Bmp.ResetPersistentMemory;
  Bmp.Free;
end.
