{$include_once Internal/Reflection.simba}
{$include_once Constants.simba}
{$include_once Menu.simba}
{$include_once Inventory.simba}
{$include_once Mouse.simba}
{$include_once Timing.simba}

const
  R_BANK_ITEM_SLOT_INDEX = 11;

  VARBIT_CURRENT_BANK_TAB = 4150;
  VARBIT_BANK_TAB_COUNT_1 = 4171;
	VARBIT_BANK_TAB_COUNT_2 = 4172;
	VARBIT_BANK_TAB_COUNT_3 = 4173;
	VARBIT_BANK_TAB_COUNT_4 = 4174;
	VARBIT_BANK_TAB_COUNT_5 = 4175;
	VARBIT_BANK_TAB_COUNT_6 = 4176;
	VARBIT_BANK_TAB_COUNT_7 = 4177;
	VARBIT_BANK_TAB_COUNT_8 = 4178;
	VARBIT_BANK_TAB_COUNT_9 = 4179;

type
  TRSBankItem = record
    ID: Int32;
    Amount: Int32;
    Slot: Int32;
    Tab: Int32;
    Name: String;
    Bounds: TBox;
  end;

Function R_BankScreen: Boolean;
begin
  Result := RSWidget.IsValid(R_INTERFACE_BANK);
end;

Function R_WaitBankScreen(timeout: UInt32): Boolean;
begin
  Result := R_WaitFunction(timeout, 50, @R_BankScreen);
end;

Function R_PinScreen: Boolean;
begin
  Result := RSWidget.IsValid(R_INTERFACE_PINSCREEN);
end;

Function R_WaitPinScreen(timeout: UInt32): Boolean;
begin
  Result := R_WaitFunction(timeout, 50, @R_PinScreen);
end;

Function R_DepositBox: Boolean;
begin
  Result := RSWidget.IsValid(R_INTERFACE_DEPOSITBOX);
end;

Function R_WaitDepositBox(timeout: UInt32): Boolean;
begin
  Result := R_WaitFunction(timeout, 50, @R_DepositBox);
end;

Function R_CurrentBankTab: Int32;
begin
  Result := RSClient.getVarbit(VARBIT_CURRENT_BANK_TAB);
end;

Function R_BankTabCount(Index: Int32): Int32;
var
  TabVarbits: Array of Int32;
begin
  if (Index < 0) or (Index > 8) then
    Exit(-1);

  TabVarbits := [VARBIT_BANK_TAB_COUNT_1, VARBIT_BANK_TAB_COUNT_2,
                 VARBIT_BANK_TAB_COUNT_3, VARBIT_BANK_TAB_COUNT_4,
                 VARBIT_BANK_TAB_COUNT_5, VARBIT_BANK_TAB_COUNT_6,
                 VARBIT_BANK_TAB_COUNT_7, VARBIT_BANK_TAB_COUNT_8,
                 VARBIT_BANK_TAB_COUNT_9];

  Result := RSClient.getVarbit(TabVarbits[Index]);
end;

Function R_BankSlotToTab(Slot: Int32): Int32;
var
  I: Int32;
  TabCount, Total: Int32;
begin
  Result := 0;
  TabCount := 0;

  for I := 0 to 8 do
  begin
    TabCount := R_BankTabCount(I);
    if TabCount = 0 then
      continue;

    Total += TabCount;
    if Slot < Total then
      Exit(I + 1);
  end;
end;

Function R_BankSlotToTabSlot(Slot: Int32): Int32;
var
  I: Int32;
  TabCount, Total: Int32;
begin
  Result := 0;
  TabCount := 0;

  for I := 0 to 8 do
  begin
    TabCount := R_BankTabCount(I);
    if TabCount = 0 then
      continue;

    Total += TabCount;
    if Slot < Total then
    begin
      Exit(TabCount - (Total - Slot)); //Exit(0 - (Total - Slot - TabCount));
    end;
  end;
  Result := Slot - Total;
end;

Function R_SelectBankTab(Index: Int32): Boolean;
var
  TabWidget: RSWidget;
begin
  if (Index < 0) or (Index > 8) then
    Exit(False);

  if not R_BankScreen then
    Exit;

  TabWidget := RSWidget.Get(R_BANK_TAB_CONTAINER.Group, R_BANK_TAB_CONTAINER.Child, Index);
  if TabWidget.ref = nil then
    Exit(False);

  Mouse.Click(TabWidget.Bounds, MOUSE_LEFT);
  TabWidget.Free;
end;

Function R_BankSlotVisible(Index: Int32): Boolean;
var
  TabContainer: RSWidget;
  TabWidget: RSWidget;
  BankBounds: TBox;
begin
  if not R_BankScreen then
    Exit(False);

  TabContainer := RSWidget.Get(R_BANK_ITEM_CONTAINER.Group, R_BANK_ITEM_CONTAINER.Child);
  if TabContainer.ref = nil then
    Exit(False);

  TabWidget := TabContainer.Child(Index);
  if TabWidget.ref = nil then
  begin
    TabContainer.Free;
    Exit(False);
  end;

  BankBounds := TabContainer.Bounds;
  TabContainer.Free;

  Result := BankBounds.Contains(TabContainer.Bounds);
  TabWidget.Free;
end;

Function R_ScrollToBankSlot(Index: Int32; UseMouseWheel: Boolean = True): Boolean;
var
  ScrollBar: RSWidget;
begin

end;

Function R_GetAllBankItems: Array of TRSBankItem;
var
  BankItemContainer, Child: RSWidget;
  ItemNodeCache: RSHashTable;
  ItemNode: RSItemNode;
  ItemIDs, ItemQuantities: Array of Int32;
  I, J: Int32;
  Garbage: RSTypeArray;
begin
  if not R_BankScreen then
    Exit;

  BankItemContainer := RSWidget.Get(R_BANK_ITEM_CONTAINER.Group, R_BANK_ITEM_CONTAINER.Child);
  if BankItemContainer.ref = nil then
    Exit;

  Garbage += BankItemContainer;
  ItemNodeCache := RSClient.ItemNodeCache;
  if ItemNodeCache.ref <> nil then
  begin
    Garbage += ItemNodeCache;
    ItemNode.ref := ItemNodeCache.GetObject(95).ref;

    if ItemNode.ref <> nil then
    begin
      Garbage += ItemNode;
      ItemIDs := ItemNode.ItemIDs;
      ItemQuantities := ItemNode.ItemQuantities;
      SetLength(Result, Length(ItemIDs));

      for I := 0 to high(ItemIDs) do
      begin
        Child := BankItemContainer.Child(I);
        if Child.ref <> nil then
        begin
          Garbage += Child;
          Result[J].ID := ItemIDs[I];
          Result[J].Amount := ItemQuantities[I];
          Result[J].Slot := I;
          Result[J].Tab := R_BankSlotToTab(I);
          Result[J].Name := Child.Name;
          Result[J].Bounds := Child.Bounds;
          Inc(J);
        end;
      end;
    end;
  end;

  SetLength(Result, J);
  Garbage.Free;
end;

Function R_FindBankItem(ID: Int32): TRSBankItem;
var
  BankItemContainer, Child: RSWidget;
  ItemNodeCache: RSHashTable;
  ItemNode: RSItemNode;
  ItemIDs, ItemQuantities: Array of Int32;
  I: Int32;
  Garbage: RSTypeArray;
begin
  Result.ID := -1;
  Result.Amount := -1;
  Result.Slot := -1;
  Result.Tab := -1;

  if not R_BankScreen then
    Exit;

  BankItemContainer := RSWidget.Get(R_BANK_ITEM_CONTAINER.Group, R_BANK_ITEM_CONTAINER.Child);
  if BankItemContainer.ref = nil then
    Exit;

  Garbage += BankItemContainer;
  ItemNodeCache := RSClient.ItemNodeCache;
  if ItemNodeCache.ref <> nil then
  begin
    Garbage += ItemNodeCache;
    ItemNode.ref := ItemNodeCache.GetObject(95).ref;

    if ItemNode.ref <> nil then
    begin
      Garbage += ItemNode;
      ItemIDs := ItemNode.ItemIDs;
      ItemQuantities := ItemNode.ItemQuantities;

      for I := 0 to high(ItemIDs) do
      begin
        if ItemIDs[I] = ID then
        begin
          Child := BankItemContainer.Child(I);
          if Child.ref <> nil then
          begin
            Garbage += Child;
            Result.ID := ItemIDs[I];
            Result.Amount := ItemQuantities[I];
            Result.Slot := I;
            Result.Tab := R_BankSlotToTab(I);
            Result.Name := Child.Name;
            Result.Bounds := Child.Bounds;
            break;
          end;
        end;
      end;
    end;
  end;

  Garbage.Free;
end;

Function R_IsBankSlotVisible(Index: Int32): Boolean;
begin
  //R_BANK_ITEM_CONTAINER
end;

Function R_DepositAll_Items: Boolean;
var
  Widget: RSWidget;
begin
  if not R_BankScreen then
    Exit;

  Widget := RSWidget.Get(R_BANK_DEPOSIT_INVENTORY_ICON.Group, R_BANK_DEPOSIT_INVENTORY_ICON.Child);
  if Widget.ref = nil then
    Exit(False);

  Mouse.Move(Widget.Bounds);
  Wait(50 + RandomRange(0, 50));
  Mouse.Click(MOUSE_LEFT);
  Widget.Free;
  Result := True;
end;

Function R_DepositAll_Equipment: Boolean;
var
  Widget: RSWidget;
begin
  if not R_BankScreen then
    Exit;

  Widget := RSWidget.Get(R_BANK_DEPOSIT_EQUIPMENT_ICON.Group, R_BANK_DEPOSIT_EQUIPMENT_ICON.Child);
  if Widget.ref = nil then
    Exit(False);

  Mouse.Move(Widget.Bounds);
  Wait(50 + RandomRange(0, 50));
  Mouse.Click(MOUSE_LEFT);
  Widget.Free;
  Result := True;
end;

Function R_DepositSlot(Index: Int32; All: Boolean = False): Boolean;
var
  InvItem: TRSInventoryItem;
begin
  if not R_BankScreen then
    Exit;

  InvItem := R_GetInventorySlotItem(Index);
  if InvItem.ID <> -1 then
  begin
    if All then
    begin
      Mouse.Click(InvItem.Bounds, MOUSE_RIGHT);
      Wait(50 + RandomRange(0, 50));
      Exit(R_ChooseOptions(['-All']));
    end;

    Mouse.Move(InvItem.Bounds);
    Wait(50 + RandomRange(0, 50));
    Mouse.Click(MOUSE_LEFT);
    Exit(True);
  end;
end;

Function R_WithdrawItem(ID: Int32): Boolean;
var
  item: TRSBankItem;
begin
  if not R_BankScreen then
    Exit(False);

  item := R_FindBankItem(ID);
  if item.ID = -1 then
    Exit(False);


end;


